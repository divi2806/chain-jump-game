"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/comlink@4.4.2";
exports.ids = ["vendor-chunks/comlink@4.4.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/comlink@4.4.2/node_modules/comlink/dist/esm/comlink.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/comlink@4.4.2/node_modules/comlink/dist/esm/comlink.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEndpoint: () => (/* binding */ createEndpoint),\n/* harmony export */   expose: () => (/* binding */ expose),\n/* harmony export */   finalizer: () => (/* binding */ finalizer),\n/* harmony export */   proxy: () => (/* binding */ proxy),\n/* harmony export */   proxyMarker: () => (/* binding */ proxyMarker),\n/* harmony export */   releaseProxy: () => (/* binding */ releaseProxy),\n/* harmony export */   transfer: () => (/* binding */ transfer),\n/* harmony export */   transferHandlers: () => (/* binding */ transferHandlers),\n/* harmony export */   windowEndpoint: () => (/* binding */ windowEndpoint),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val)=>typeof val === \"object\" && val !== null || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */ const proxyTransferHandler = {\n    canHandle: (val)=>isObject(val) && val[proxyMarker],\n    serialize (obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [\n            port2,\n            [\n                port2\n            ]\n        ];\n    },\n    deserialize (port) {\n        port.start();\n        return wrap(port);\n    }\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */ const throwTransferHandler = {\n    canHandle: (value)=>isObject(value) && throwMarker in value,\n    serialize ({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack\n                }\n            };\n        } else {\n            serialized = {\n                isError: false,\n                value\n            };\n        }\n        return [\n            serialized,\n            []\n        ];\n    },\n    deserialize (serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    }\n};\n/**\n * Allows customizing the serialization of certain values.\n */ const transferHandlers = new Map([\n    [\n        \"proxy\",\n        proxyTransferHandler\n    ],\n    [\n        \"throw\",\n        throwTransferHandler\n    ]\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins){\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\n    \"*\"\n]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({\n            path: []\n        }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop)=>obj[prop], obj);\n            const rawValue = path.reduce((obj, prop)=>obj[prop], obj);\n            switch(type){\n                case \"GET\" /* MessageType.GET */ :\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */ :\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */ :\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */ :\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */ :\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [\n                            port1\n                        ]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */ :\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        } catch (value) {\n            returnValue = {\n                value,\n                [throwMarker]: 0\n            };\n        }\n        Promise.resolve(returnValue).catch((value)=>{\n            return {\n                value,\n                [throwMarker]: 0\n            };\n        }).then((returnValue)=>{\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), {\n                id\n            }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */ ) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        }).catch((error)=>{\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), {\n                id\n            }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint)) endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        } finally{\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */ \n    }).then(()=>{\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis && new FinalizationRegistry((ep)=>{\n    const newCount = (proxyCounter.get(ep) || 0) - 1;\n    proxyCounter.set(ep, newCount);\n    if (newCount === 0) {\n        releaseEndpoint(ep);\n    }\n});\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function() {}) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get (_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return ()=>{\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return {\n                        then: ()=>proxy\n                    };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */ ,\n                    path: path.map((p)=>p.toString())\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [\n                ...path,\n                prop\n            ]);\n        },\n        set (_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */ ,\n                path: [\n                    ...path,\n                    prop\n                ].map((p)=>p.toString()),\n                value\n            }, transferables).then(fromWireValue);\n        },\n        apply (_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */ \n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */ ,\n                path: path.map((p)=>p.toString()),\n                argumentList\n            }, transferables).then(fromWireValue);\n        },\n        construct (_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */ ,\n                path: path.map((p)=>p.toString()),\n                argumentList\n            }, transferables).then(fromWireValue);\n        }\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [\n        processed.map((v)=>v[0]),\n        myFlat(processed.map((v)=>v[1]))\n    ];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, {\n        [proxyMarker]: true\n    });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables)=>w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context)\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers){\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */ ,\n                    name,\n                    value: serializedValue\n                },\n                transferables\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */ ,\n            value\n        },\n        transferCache.get(value) || []\n    ];\n}\nfunction fromWireValue(value) {\n    switch(value.type){\n        case \"HANDLER\" /* WireValueType.HANDLER */ :\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */ :\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve)=>{\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({\n            id\n        }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4).fill(0).map(()=>Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join(\"-\");\n}\n //# sourceMappingURL=comlink.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY29tbGlua0A0LjQuMi9ub2RlX21vZHVsZXMvY29tbGluay9kaXN0L2VzbS9jb21saW5rLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUNELE1BQU1BLGNBQWNDLE9BQU87QUFDM0IsTUFBTUMsaUJBQWlCRCxPQUFPO0FBQzlCLE1BQU1FLGVBQWVGLE9BQU87QUFDNUIsTUFBTUcsWUFBWUgsT0FBTztBQUN6QixNQUFNSSxjQUFjSixPQUFPO0FBQzNCLE1BQU1LLFdBQVcsQ0FBQ0MsTUFBUSxPQUFRQSxRQUFRLFlBQVlBLFFBQVEsUUFBUyxPQUFPQSxRQUFRO0FBQ3RGOztDQUVDLEdBQ0QsTUFBTUMsdUJBQXVCO0lBQ3pCQyxXQUFXLENBQUNGLE1BQVFELFNBQVNDLFFBQVFBLEdBQUcsQ0FBQ1AsWUFBWTtJQUNyRFUsV0FBVUMsR0FBRztRQUNULE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUUsR0FBRyxJQUFJQztRQUM3QkMsT0FBT0osS0FBS0M7UUFDWixPQUFPO1lBQUNDO1lBQU87Z0JBQUNBO2FBQU07U0FBQztJQUMzQjtJQUNBRyxhQUFZQyxJQUFJO1FBQ1pBLEtBQUtDLEtBQUs7UUFDVixPQUFPQyxLQUFLRjtJQUNoQjtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNRyx1QkFBdUI7SUFDekJYLFdBQVcsQ0FBQ1ksUUFBVWYsU0FBU2UsVUFBVWhCLGVBQWVnQjtJQUN4RFgsV0FBVSxFQUFFVyxLQUFLLEVBQUU7UUFDZixJQUFJQztRQUNKLElBQUlELGlCQUFpQkUsT0FBTztZQUN4QkQsYUFBYTtnQkFDVEUsU0FBUztnQkFDVEgsT0FBTztvQkFDSEksU0FBU0osTUFBTUksT0FBTztvQkFDdEJDLE1BQU1MLE1BQU1LLElBQUk7b0JBQ2hCQyxPQUFPTixNQUFNTSxLQUFLO2dCQUN0QjtZQUNKO1FBQ0osT0FDSztZQUNETCxhQUFhO2dCQUFFRSxTQUFTO2dCQUFPSDtZQUFN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QUFFaUI7UUFBRyxHQUFHZ0YsTUFBTUw7SUFDL0M7QUFDSjtBQUNBLFNBQVNRO0lBQ0wsT0FBTyxJQUFJZCxNQUFNLEdBQ1plLElBQUksQ0FBQyxHQUNMaEYsR0FBRyxDQUFDLElBQU1pRixLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBS0MsT0FBT0MsZ0JBQWdCLEVBQUU3QixRQUFRLENBQUMsS0FDdkU4QixJQUFJLENBQUM7QUFDZDtBQUVpSSxDQUNqSSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFjZS1qdW1wLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vY29tbGlua0A0LjQuMi9ub2RlX21vZHVsZXMvY29tbGluay9kaXN0L2VzbS9jb21saW5rLm1qcz8wYTAzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IHByb3h5TWFya2VyID0gU3ltYm9sKFwiQ29tbGluay5wcm94eVwiKTtcbmNvbnN0IGNyZWF0ZUVuZHBvaW50ID0gU3ltYm9sKFwiQ29tbGluay5lbmRwb2ludFwiKTtcbmNvbnN0IHJlbGVhc2VQcm94eSA9IFN5bWJvbChcIkNvbWxpbmsucmVsZWFzZVByb3h5XCIpO1xuY29uc3QgZmluYWxpemVyID0gU3ltYm9sKFwiQ29tbGluay5maW5hbGl6ZXJcIik7XG5jb25zdCB0aHJvd01hcmtlciA9IFN5bWJvbChcIkNvbWxpbmsudGhyb3duXCIpO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiAodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiB2YWwgIT09IG51bGwpIHx8IHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIjtcbi8qKlxuICogSW50ZXJuYWwgdHJhbnNmZXIgaGFuZGxlIHRvIGhhbmRsZSBvYmplY3RzIG1hcmtlZCB0byBwcm94eS5cbiAqL1xuY29uc3QgcHJveHlUcmFuc2ZlckhhbmRsZXIgPSB7XG4gICAgY2FuSGFuZGxlOiAodmFsKSA9PiBpc09iamVjdCh2YWwpICYmIHZhbFtwcm94eU1hcmtlcl0sXG4gICAgc2VyaWFsaXplKG9iaikge1xuICAgICAgICBjb25zdCB7IHBvcnQxLCBwb3J0MiB9ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGV4cG9zZShvYmosIHBvcnQxKTtcbiAgICAgICAgcmV0dXJuIFtwb3J0MiwgW3BvcnQyXV07XG4gICAgfSxcbiAgICBkZXNlcmlhbGl6ZShwb3J0KSB7XG4gICAgICAgIHBvcnQuc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIHdyYXAocG9ydCk7XG4gICAgfSxcbn07XG4vKipcbiAqIEludGVybmFsIHRyYW5zZmVyIGhhbmRsZXIgdG8gaGFuZGxlIHRocm93biBleGNlcHRpb25zLlxuICovXG5jb25zdCB0aHJvd1RyYW5zZmVySGFuZGxlciA9IHtcbiAgICBjYW5IYW5kbGU6ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpICYmIHRocm93TWFya2VyIGluIHZhbHVlLFxuICAgIHNlcmlhbGl6ZSh7IHZhbHVlIH0pIHtcbiAgICAgICAgbGV0IHNlcmlhbGl6ZWQ7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkID0ge1xuICAgICAgICAgICAgICAgIGlzRXJyb3I6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdmFsdWUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdmFsdWUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHZhbHVlLnN0YWNrLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VyaWFsaXplZCA9IHsgaXNFcnJvcjogZmFsc2UsIHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzZXJpYWxpemVkLCBbXV07XG4gICAgfSxcbiAgICBkZXNlcmlhbGl6ZShzZXJpYWxpemVkKSB7XG4gICAgICAgIGlmIChzZXJpYWxpemVkLmlzRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKHNlcmlhbGl6ZWQudmFsdWUubWVzc2FnZSksIHNlcmlhbGl6ZWQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IHNlcmlhbGl6ZWQudmFsdWU7XG4gICAgfSxcbn07XG4vKipcbiAqIEFsbG93cyBjdXN0b21pemluZyB0aGUgc2VyaWFsaXphdGlvbiBvZiBjZXJ0YWluIHZhbHVlcy5cbiAqL1xuY29uc3QgdHJhbnNmZXJIYW5kbGVycyA9IG5ldyBNYXAoW1xuICAgIFtcInByb3h5XCIsIHByb3h5VHJhbnNmZXJIYW5kbGVyXSxcbiAgICBbXCJ0aHJvd1wiLCB0aHJvd1RyYW5zZmVySGFuZGxlcl0sXG5dKTtcbmZ1bmN0aW9uIGlzQWxsb3dlZE9yaWdpbihhbGxvd2VkT3JpZ2lucywgb3JpZ2luKSB7XG4gICAgZm9yIChjb25zdCBhbGxvd2VkT3JpZ2luIG9mIGFsbG93ZWRPcmlnaW5zKSB7XG4gICAgICAgIGlmIChvcmlnaW4gPT09IGFsbG93ZWRPcmlnaW4gfHwgYWxsb3dlZE9yaWdpbiA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxvd2VkT3JpZ2luIGluc3RhbmNlb2YgUmVnRXhwICYmIGFsbG93ZWRPcmlnaW4udGVzdChvcmlnaW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBleHBvc2Uob2JqLCBlcCA9IGdsb2JhbFRoaXMsIGFsbG93ZWRPcmlnaW5zID0gW1wiKlwiXSkge1xuICAgIGVwLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uIGNhbGxiYWNrKGV2KSB7XG4gICAgICAgIGlmICghZXYgfHwgIWV2LmRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQWxsb3dlZE9yaWdpbihhbGxvd2VkT3JpZ2lucywgZXYub3JpZ2luKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIG9yaWdpbiAnJHtldi5vcmlnaW59JyBmb3IgY29tbGluayBwcm94eWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaWQsIHR5cGUsIHBhdGggfSA9IE9iamVjdC5hc3NpZ24oeyBwYXRoOiBbXSB9LCBldi5kYXRhKTtcbiAgICAgICAgY29uc3QgYXJndW1lbnRMaXN0ID0gKGV2LmRhdGEuYXJndW1lbnRMaXN0IHx8IFtdKS5tYXAoZnJvbVdpcmVWYWx1ZSk7XG4gICAgICAgIGxldCByZXR1cm5WYWx1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHBhdGguc2xpY2UoMCwgLTEpLnJlZHVjZSgob2JqLCBwcm9wKSA9PiBvYmpbcHJvcF0sIG9iaik7XG4gICAgICAgICAgICBjb25zdCByYXdWYWx1ZSA9IHBhdGgucmVkdWNlKChvYmosIHByb3ApID0+IG9ialtwcm9wXSwgb2JqKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJHRVRcIiAvKiBNZXNzYWdlVHlwZS5HRVQgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gcmF3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlNFVFwiIC8qIE1lc3NhZ2VUeXBlLlNFVCAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50W3BhdGguc2xpY2UoLTEpWzBdXSA9IGZyb21XaXJlVmFsdWUoZXYuZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFQUExZXCIgLyogTWVzc2FnZVR5cGUuQVBQTFkgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gcmF3VmFsdWUuYXBwbHkocGFyZW50LCBhcmd1bWVudExpc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJDT05TVFJVQ1RcIiAvKiBNZXNzYWdlVHlwZS5DT05TVFJVQ1QgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IHJhd1ZhbHVlKC4uLmFyZ3VtZW50TGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHByb3h5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiRU5EUE9JTlRcIiAvKiBNZXNzYWdlVHlwZS5FTkRQT0lOVCAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3NlKG9iaiwgcG9ydDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cmFuc2Zlcihwb3J0MSwgW3BvcnQxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlJFTEVBU0VcIiAvKiBNZXNzYWdlVHlwZS5SRUxFQVNFICovOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHsgdmFsdWUsIFt0aHJvd01hcmtlcl06IDAgfTtcbiAgICAgICAgfVxuICAgICAgICBQcm9taXNlLnJlc29sdmUocmV0dXJuVmFsdWUpXG4gICAgICAgICAgICAuY2F0Y2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgW3Rocm93TWFya2VyXTogMCB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHJldHVyblZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbd2lyZVZhbHVlLCB0cmFuc2ZlcmFibGVzXSA9IHRvV2lyZVZhbHVlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgIGVwLnBvc3RNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd2lyZVZhbHVlKSwgeyBpZCB9KSwgdHJhbnNmZXJhYmxlcyk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJSRUxFQVNFXCIgLyogTWVzc2FnZVR5cGUuUkVMRUFTRSAqLykge1xuICAgICAgICAgICAgICAgIC8vIGRldGFjaCBhbmQgZGVhY3RpdmUgYWZ0ZXIgc2VuZGluZyByZWxlYXNlIHJlc3BvbnNlIGFib3ZlLlxuICAgICAgICAgICAgICAgIGVwLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBjbG9zZUVuZFBvaW50KGVwKTtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxpemVyIGluIG9iaiAmJiB0eXBlb2Ygb2JqW2ZpbmFsaXplcl0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBvYmpbZmluYWxpemVyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIFNlbmQgU2VyaWFsaXphdGlvbiBFcnJvciBUbyBDYWxsZXJcbiAgICAgICAgICAgIGNvbnN0IFt3aXJlVmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gdG9XaXJlVmFsdWUoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgVHlwZUVycm9yKFwiVW5zZXJpYWxpemFibGUgcmV0dXJuIHZhbHVlXCIpLFxuICAgICAgICAgICAgICAgIFt0aHJvd01hcmtlcl06IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVwLnBvc3RNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd2lyZVZhbHVlKSwgeyBpZCB9KSwgdHJhbnNmZXJhYmxlcyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChlcC5zdGFydCkge1xuICAgICAgICBlcC5zdGFydCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTWVzc2FnZVBvcnQoZW5kcG9pbnQpIHtcbiAgICByZXR1cm4gZW5kcG9pbnQuY29uc3RydWN0b3IubmFtZSA9PT0gXCJNZXNzYWdlUG9ydFwiO1xufVxuZnVuY3Rpb24gY2xvc2VFbmRQb2ludChlbmRwb2ludCkge1xuICAgIGlmIChpc01lc3NhZ2VQb3J0KGVuZHBvaW50KSlcbiAgICAgICAgZW5kcG9pbnQuY2xvc2UoKTtcbn1cbmZ1bmN0aW9uIHdyYXAoZXAsIHRhcmdldCkge1xuICAgIGNvbnN0IHBlbmRpbmdMaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgZXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldikge1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGV2O1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEuaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNvbHZlciA9IHBlbmRpbmdMaXN0ZW5lcnMuZ2V0KGRhdGEuaWQpO1xuICAgICAgICBpZiAoIXJlc29sdmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc29sdmVyKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgcGVuZGluZ0xpc3RlbmVycy5kZWxldGUoZGF0YS5pZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY3JlYXRlUHJveHkoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIFtdLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNSZWxlYXNlZCkge1xuICAgIGlmIChpc1JlbGVhc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3h5IGhhcyBiZWVuIHJlbGVhc2VkIGFuZCBpcyBub3QgdXNlYWJsZVwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWxlYXNlRW5kcG9pbnQoZXApIHtcbiAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgbmV3IE1hcCgpLCB7XG4gICAgICAgIHR5cGU6IFwiUkVMRUFTRVwiIC8qIE1lc3NhZ2VUeXBlLlJFTEVBU0UgKi8sXG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIGNsb3NlRW5kUG9pbnQoZXApO1xuICAgIH0pO1xufVxuY29uc3QgcHJveHlDb3VudGVyID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHByb3h5RmluYWxpemVycyA9IFwiRmluYWxpemF0aW9uUmVnaXN0cnlcIiBpbiBnbG9iYWxUaGlzICYmXG4gICAgbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KChlcCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdDb3VudCA9IChwcm94eUNvdW50ZXIuZ2V0KGVwKSB8fCAwKSAtIDE7XG4gICAgICAgIHByb3h5Q291bnRlci5zZXQoZXAsIG5ld0NvdW50KTtcbiAgICAgICAgaWYgKG5ld0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZWxlYXNlRW5kcG9pbnQoZXApO1xuICAgICAgICB9XG4gICAgfSk7XG5mdW5jdGlvbiByZWdpc3RlclByb3h5KHByb3h5LCBlcCkge1xuICAgIGNvbnN0IG5ld0NvdW50ID0gKHByb3h5Q291bnRlci5nZXQoZXApIHx8IDApICsgMTtcbiAgICBwcm94eUNvdW50ZXIuc2V0KGVwLCBuZXdDb3VudCk7XG4gICAgaWYgKHByb3h5RmluYWxpemVycykge1xuICAgICAgICBwcm94eUZpbmFsaXplcnMucmVnaXN0ZXIocHJveHksIGVwLCBwcm94eSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdW5yZWdpc3RlclByb3h5KHByb3h5KSB7XG4gICAgaWYgKHByb3h5RmluYWxpemVycykge1xuICAgICAgICBwcm94eUZpbmFsaXplcnMudW5yZWdpc3Rlcihwcm94eSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJveHkoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHBhdGggPSBbXSwgdGFyZ2V0ID0gZnVuY3Rpb24gKCkgeyB9KSB7XG4gICAgbGV0IGlzUHJveHlSZWxlYXNlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHRhcmdldCwge1xuICAgICAgICBnZXQoX3RhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTtcbiAgICAgICAgICAgIGlmIChwcm9wID09PSByZWxlYXNlUHJveHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyUHJveHkocHJveHkpO1xuICAgICAgICAgICAgICAgICAgICByZWxlYXNlRW5kcG9pbnQoZXApO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nTGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlzUHJveHlSZWxlYXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wID09PSBcInRoZW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0aGVuOiAoKSA9PiBwcm94eSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByID0gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkdFVFwiIC8qIE1lc3NhZ2VUeXBlLkdFVCAqLyxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcGF0aC5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgfSkudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gci50aGVuLmJpbmQocik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJveHkoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIFsuLi5wYXRoLCBwcm9wXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldChfdGFyZ2V0LCBwcm9wLCByYXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBFUzYgUHJveHkgSGFuZGxlciBgc2V0YCBtZXRob2RzIGFyZSBzdXBwb3NlZCB0byByZXR1cm4gYVxuICAgICAgICAgICAgLy8gYm9vbGVhbi4gVG8gc2hvdyBnb29kIHdpbGwsIHdlIHJldHVybiB0cnVlIGFzeW5jaHJvbm91c2x5IMKvXFxfKOODhClfL8KvXG4gICAgICAgICAgICBjb25zdCBbdmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gdG9XaXJlVmFsdWUocmF3VmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlNFVFwiIC8qIE1lc3NhZ2VUeXBlLlNFVCAqLyxcbiAgICAgICAgICAgICAgICBwYXRoOiBbLi4ucGF0aCwgcHJvcF0ubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcykudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwbHkoX3RhcmdldCwgX3RoaXNBcmcsIHJhd0FyZ3VtZW50TGlzdCkge1xuICAgICAgICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdCA9PT0gY3JlYXRlRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkVORFBPSU5UXCIgLyogTWVzc2FnZVR5cGUuRU5EUE9JTlQgKi8sXG4gICAgICAgICAgICAgICAgfSkudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGp1c3QgcHJldGVuZCB0aGF0IGBiaW5kKClgIGRpZG7igJl0IGhhcHBlbi5cbiAgICAgICAgICAgIGlmIChsYXN0ID09PSBcImJpbmRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcm94eShlcCwgcGVuZGluZ0xpc3RlbmVycywgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW2FyZ3VtZW50TGlzdCwgdHJhbnNmZXJhYmxlc10gPSBwcm9jZXNzQXJndW1lbnRzKHJhd0FyZ3VtZW50TGlzdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiQVBQTFlcIiAvKiBNZXNzYWdlVHlwZS5BUFBMWSAqLyxcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudExpc3QsXG4gICAgICAgICAgICB9LCB0cmFuc2ZlcmFibGVzKS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBjb25zdHJ1Y3QoX3RhcmdldCwgcmF3QXJndW1lbnRMaXN0KSB7XG4gICAgICAgICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgICAgICAgY29uc3QgW2FyZ3VtZW50TGlzdCwgdHJhbnNmZXJhYmxlc10gPSBwcm9jZXNzQXJndW1lbnRzKHJhd0FyZ3VtZW50TGlzdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiQ09OU1RSVUNUXCIgLyogTWVzc2FnZVR5cGUuQ09OU1RSVUNUICovLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50TGlzdCxcbiAgICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpLnRoZW4oZnJvbVdpcmVWYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJQcm94eShwcm94eSwgZXApO1xuICAgIHJldHVybiBwcm94eTtcbn1cbmZ1bmN0aW9uIG15RmxhdChhcnIpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyKTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NBcmd1bWVudHMoYXJndW1lbnRMaXN0KSB7XG4gICAgY29uc3QgcHJvY2Vzc2VkID0gYXJndW1lbnRMaXN0Lm1hcCh0b1dpcmVWYWx1ZSk7XG4gICAgcmV0dXJuIFtwcm9jZXNzZWQubWFwKCh2KSA9PiB2WzBdKSwgbXlGbGF0KHByb2Nlc3NlZC5tYXAoKHYpID0+IHZbMV0pKV07XG59XG5jb25zdCB0cmFuc2ZlckNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHRyYW5zZmVyKG9iaiwgdHJhbnNmZXJzKSB7XG4gICAgdHJhbnNmZXJDYWNoZS5zZXQob2JqLCB0cmFuc2ZlcnMpO1xuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBwcm94eShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvYmosIHsgW3Byb3h5TWFya2VyXTogdHJ1ZSB9KTtcbn1cbmZ1bmN0aW9uIHdpbmRvd0VuZHBvaW50KHcsIGNvbnRleHQgPSBnbG9iYWxUaGlzLCB0YXJnZXRPcmlnaW4gPSBcIipcIikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvc3RNZXNzYWdlOiAobXNnLCB0cmFuc2ZlcmFibGVzKSA9PiB3LnBvc3RNZXNzYWdlKG1zZywgdGFyZ2V0T3JpZ2luLCB0cmFuc2ZlcmFibGVzKSxcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogY29udGV4dC5hZGRFdmVudExpc3RlbmVyLmJpbmQoY29udGV4dCksXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGNvbnRleHQucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKGNvbnRleHQpLFxuICAgIH07XG59XG5mdW5jdGlvbiB0b1dpcmVWYWx1ZSh2YWx1ZSkge1xuICAgIGZvciAoY29uc3QgW25hbWUsIGhhbmRsZXJdIG9mIHRyYW5zZmVySGFuZGxlcnMpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIuY2FuSGFuZGxlKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgW3NlcmlhbGl6ZWRWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSBoYW5kbGVyLnNlcmlhbGl6ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJIQU5ETEVSXCIgLyogV2lyZVZhbHVlVHlwZS5IQU5ETEVSICovLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc2VyaWFsaXplZFZhbHVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJhYmxlcyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJSQVdcIiAvKiBXaXJlVmFsdWVUeXBlLlJBVyAqLyxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9LFxuICAgICAgICB0cmFuc2ZlckNhY2hlLmdldCh2YWx1ZSkgfHwgW10sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGZyb21XaXJlVmFsdWUodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkhBTkRMRVJcIiAvKiBXaXJlVmFsdWVUeXBlLkhBTkRMRVIgKi86XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmZXJIYW5kbGVycy5nZXQodmFsdWUubmFtZSkuZGVzZXJpYWxpemUodmFsdWUudmFsdWUpO1xuICAgICAgICBjYXNlIFwiUkFXXCIgLyogV2lyZVZhbHVlVHlwZS5SQVcgKi86XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywgbXNnLCB0cmFuc2ZlcnMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSBnZW5lcmF0ZVVVSUQoKTtcbiAgICAgICAgcGVuZGluZ0xpc3RlbmVycy5zZXQoaWQsIHJlc29sdmUpO1xuICAgICAgICBpZiAoZXAuc3RhcnQpIHtcbiAgICAgICAgICAgIGVwLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZXAucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbih7IGlkIH0sIG1zZyksIHRyYW5zZmVycyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheSg0KVxuICAgICAgICAuZmlsbCgwKVxuICAgICAgICAubWFwKCgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKS50b1N0cmluZygxNikpXG4gICAgICAgIC5qb2luKFwiLVwiKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRW5kcG9pbnQsIGV4cG9zZSwgZmluYWxpemVyLCBwcm94eSwgcHJveHlNYXJrZXIsIHJlbGVhc2VQcm94eSwgdHJhbnNmZXIsIHRyYW5zZmVySGFuZGxlcnMsIHdpbmRvd0VuZHBvaW50LCB3cmFwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21saW5rLm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJwcm94eU1hcmtlciIsIlN5bWJvbCIsImNyZWF0ZUVuZHBvaW50IiwicmVsZWFzZVByb3h5IiwiZmluYWxpemVyIiwidGhyb3dNYXJrZXIiLCJpc09iamVjdCIsInZhbCIsInByb3h5VHJhbnNmZXJIYW5kbGVyIiwiY2FuSGFuZGxlIiwic2VyaWFsaXplIiwib2JqIiwicG9ydDEiLCJwb3J0MiIsIk1lc3NhZ2VDaGFubmVsIiwiZXhwb3NlIiwiZGVzZXJpYWxpemUiLCJwb3J0Iiwic3RhcnQiLCJ3cmFwIiwidGhyb3dUcmFuc2ZlckhhbmRsZXIiLCJ2YWx1ZSIsInNlcmlhbGl6ZWQiLCJFcnJvciIsImlzRXJyb3IiLCJtZXNzYWdlIiwibmFtZSIsInN0YWNrIiwiT2JqZWN0IiwiYXNzaWduIiwidHJhbnNmZXJIYW5kbGVycyIsIk1hcCIsImlzQWxsb3dlZE9yaWdpbiIsImFsbG93ZWRPcmlnaW5zIiwib3JpZ2luIiwiYWxsb3dlZE9yaWdpbiIsIlJlZ0V4cCIsInRlc3QiLCJlcCIsImdsb2JhbFRoaXMiLCJhZGRFdmVudExpc3RlbmVyIiwiY2FsbGJhY2siLCJldiIsImRhdGEiLCJjb25zb2xlIiwid2FybiIsImlkIiwidHlwZSIsInBhdGgiLCJhcmd1bWVudExpc3QiLCJtYXAiLCJmcm9tV2lyZVZhbHVlIiwicmV0dXJuVmFsdWUiLCJwYXJlbnQiLCJzbGljZSIsInJlZHVjZSIsInByb3AiLCJyYXdWYWx1ZSIsImFwcGx5IiwicHJveHkiLCJ0cmFuc2ZlciIsInVuZGVmaW5lZCIsIlByb21pc2UiLCJyZXNvbHZlIiwiY2F0Y2giLCJ0aGVuIiwid2lyZVZhbHVlIiwidHJhbnNmZXJhYmxlcyIsInRvV2lyZVZhbHVlIiwicG9zdE1lc3NhZ2UiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xvc2VFbmRQb2ludCIsImVycm9yIiwiVHlwZUVycm9yIiwiaXNNZXNzYWdlUG9ydCIsImVuZHBvaW50IiwiY29uc3RydWN0b3IiLCJjbG9zZSIsInRhcmdldCIsInBlbmRpbmdMaXN0ZW5lcnMiLCJoYW5kbGVNZXNzYWdlIiwicmVzb2x2ZXIiLCJnZXQiLCJkZWxldGUiLCJjcmVhdGVQcm94eSIsInRocm93SWZQcm94eVJlbGVhc2VkIiwiaXNSZWxlYXNlZCIsInJlbGVhc2VFbmRwb2ludCIsInJlcXVlc3RSZXNwb25zZU1lc3NhZ2UiLCJwcm94eUNvdW50ZXIiLCJXZWFrTWFwIiwicHJveHlGaW5hbGl6ZXJzIiwiRmluYWxpemF0aW9uUmVnaXN0cnkiLCJuZXdDb3VudCIsInNldCIsInJlZ2lzdGVyUHJveHkiLCJyZWdpc3RlciIsInVucmVnaXN0ZXJQcm94eSIsInVucmVnaXN0ZXIiLCJpc1Byb3h5UmVsZWFzZWQiLCJQcm94eSIsIl90YXJnZXQiLCJjbGVhciIsImxlbmd0aCIsInIiLCJwIiwidG9TdHJpbmciLCJiaW5kIiwiX3RoaXNBcmciLCJyYXdBcmd1bWVudExpc3QiLCJsYXN0IiwicHJvY2Vzc0FyZ3VtZW50cyIsImNvbnN0cnVjdCIsIm15RmxhdCIsImFyciIsIkFycmF5IiwicHJvdG90eXBlIiwiY29uY2F0IiwicHJvY2Vzc2VkIiwidiIsInRyYW5zZmVyQ2FjaGUiLCJ0cmFuc2ZlcnMiLCJ3aW5kb3dFbmRwb2ludCIsInciLCJjb250ZXh0IiwidGFyZ2V0T3JpZ2luIiwibXNnIiwiaGFuZGxlciIsInNlcmlhbGl6ZWRWYWx1ZSIsImdlbmVyYXRlVVVJRCIsImZpbGwiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiam9pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/comlink@4.4.2/node_modules/comlink/dist/esm/comlink.mjs\n");

/***/ })

};
;